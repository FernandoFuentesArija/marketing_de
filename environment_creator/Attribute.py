from environment_creator.config import ConfigVariablesEnv
from common_tools.logger import log
from common_tools.config import ConfigCommonVariables
from common_tools.config import ConfigErrorMessages
import random

class Attribute:
    """ Base class to manage attributes

    The environment is composed of objects. These objects have characteristics that define them. Those characteristics
    we are going to call them attributes and they are going to be generated by this class.
    We are going to have 5 different types of atributes:
    1-NUMBER: We can generate a list of numbers, randomly or in sequence. We also define the precision and the range.
    2-TEXT:
    3-DATE:
    4-COMBINED:
    5-CONDITIONED:
    Note: The list returned, can be of unique elements, or can have duplicates. It will be defined in the
    <attribute_constr> variable.

    ATTRIBUTES
    ---------
    It's composed:
    - self.bbdd: Object that represents the connection to the bbdd
    - self.att_dic: Dictionary with the recipe to create the attribute
    - self.att_num: Number of attributes to create (inside a list)

    PUBLIC METHODS
    ---------------
    - create_attribute: This is the single entry point to create a list of attributes.

    PRIVATE METHODS
    ---------------
    - create_numbers
    - create_random_numbers
    - create_seq_numbers

    PERSISTENCE
    ------------
    - El listado

    RELATIONS WITH OTHER ELEMENTS
    ------------------------------
    -[element name]: La
    """

    # Le pasamos una conexion a cada instancia (puede ser la misma)
    def __init__(self, ddbb_conn):
        """ For every instance we need 3 parameters
        :param ddbb_conn: Object that represents the connection to the bbdd
        """
        self.bbdd = ddbb_conn

    ####################
    ## NUMBER METHODS ##
    ####################

    def create_numbers(self,list_length):
        """ This function creates a list of numbers
        The dictionary that will describe how to generate the list of numbers will have the following keys
        - 'PRECISION': Will describe the length of the decimal part.
           Ej: if we want describe 9999.99  Ej_dic: 'PRECISION':'2'
        - 'RANGE': Establish the integer range (min-max) where the number are going to be created.
           Ej: if we want numbers between 10 and 100  Ej_dic: 'RANGE':'10-100'
        - 'GENERATION': It describes how the numbers are going to be created. The can be create randomly or as a
           secuence with certain hop.
           Ej_dic: 'GENERATION':'RANDOM' or 'GENERATION':'SEQUENTIAL'
        - 'HOP': In a sequential number generation is the separation between generated numbers.
           Ej: if we want 2,4,6,...  Ej_dic: 'HOP':'2'
        :param list_length: number of numbers to generate and return in a list
        :return: list of numbers generated
        """
        # First we obtain all the relevant information that we need
        this_precision = self.att_dic[ConfigVariablesEnv.num_precision]
        this_range = self.att_dic[ConfigVariablesEnv.num_range]
        this_generation = self.att_dic[ConfigVariablesEnv.num_generation]
        # From the precision we obtain de decimal and integer accuracy
        dec_pre = int(this_precision)
        # From the range we obtain de max and min numbers
        min_rang, max_rang = this_range.split('-')
        min_rang = int(min_rang)
        max_rang = int(max_rang)
        # Depending on the type of generation
        if this_generation == ConfigVariablesEnv.num_gen_seq:
            # If the generation is sequential we need to recover the hop.
            this_hop_str = self.att_dic[ConfigVariablesEnv.num_hop]
            this_hop_int = int(this_hop_str)
            ret_list = self.create_seq_numbers(min_rang, max_rang, list_length, this_hop_int)
            return ret_list
        elif this_generation == ConfigVariablesEnv.num_gen_random:
            ret_list = self.create_random_numbers(dec_pre, min_rang, max_rang, list_length)
            return ret_list
        else:
            list_var_message = [ConfigErrorMessages.ErrorCode001, this_generation, ConfigVariablesEnv.num_gen_seq,
                                ConfigVariablesEnv.num_gen_random]
            log_object = 'Attribute.create_numbers()'
            log(ConfigCommonVariables.level_error, list_var_message, log_object)


    def create_random_numbers(self,decimal_prec,min_num, max_num, list_length):
        """ This function will create and return a list of random numbers
        :param decimal_prec: Number of digits for the decimal part
        :param min_num: Minimun number allowed
        :param max_num: Maximun number allowed
        :param list_length: number of numbers to generate and return in a list
        :return: list of random numbers generated
        """
        # The list to return
        ret_list = []
        # We create the decimal deviation
        ten_mult = 10**decimal_prec
        # We escalate the range if we have decimals
        min_num_scal = min_num * ten_mult
        max_num_scal = max_num * ten_mult
        for i in range(list_length):
            new_num_scal = random.randint(min_num_scal,max_num_scal)
            new_num = new_num_scal / ten_mult
            ret_list.append(new_num)
        return ret_list

    def create_seq_numbers(self,min_num, max_num, list_length,hop):
        """ This function will create and return a list of sequence integer numbers
        :param decimal_prec: Number of digits for the decimal part
        :param min_num: Minimun number allowed
        :param max_num: Maximun number allowed
        :param list_length: number of numbers to generate and return in a list
        :return: list of sequential numbers generated
        """
        # We use range
        new_range = range(min_num,max_num,hop)
        new_range_list = list(new_range)
        # Validation of the size
        new_range_list_len = len(new_range_list)
        if new_range_list_len != list_length:
            list_var_message = [ConfigErrorMessages.ErrorCode002, str(min_num), str(max_num), str(hop),
                                str(new_range_list_len), str (list_length)]
            log_object = 'Attribute.create_seq_numbers()'
            log(ConfigCommonVariables.level_error, list_var_message, log_object)
        # Finish
        return new_range_list

    ####################
    ##  TEXT METHODS  ##
    ####################

    def create_text(self,list_length):
        """ This function creates a list of texts
        The dictionary that will describe how to generate the list of numbers will have the following keys
        - 'LENGTH': Will describe the length of the text (only use for 'GENERATION':'RANDOM').
           Ej: if we want a text of 10 Characters max  Ej_dic: 'LENGTH':'10'
        - 'GENERATION': It describes how the text are going to be created. We have 3 options:
           - BBDD: We take the text from a populated BBDD.
           - RANDOM: We generate a random text.
           - CTE: We use a constant.
           Ej_dic: 'GENERATION':'BBDD' or 'GENERATION':'RANDOM' or 'GENERATION':'CTE'
        - 'BBDD_NAME': If 'GENERATION':'BBDD' we need to inform this key with the name of the BBDD.
           Ej: if the BBDD name is environmentBBDD  Ej_dic: 'BBDD_NAME':'environmentBBDD'
        - 'BBDD_SOURCE': If 'GENERATION':'BBDD' we need to inform source where we have to search for the field. In a
           relation database will be the table in a document database will be collections.
           Ej: if the BBDD collection is data_person_names  Ej_dic: 'BBDD_SOURCE':'data_person_names'
        - 'BBDD_FIELD': If 'GENERATION':'BBDD' we need to inform which field to pick as the text. In a
           relation database will be the column name in a document database will be key name.
           Ej: if the BBDD key is name  Ej_dic: 'BBDD_FIELD':'name'
        - 'CTE_STR': If 'GENERATION':'CTE' we need to inform which constant we are going to use
           Ej: if we want to put 'Hello world'  Ej_dic: 'CTE_STR':'Hello world'
        :param list_length: number of numbers to generate and return in a list
        :return: list of numbers generated
        """
        pass

    ####################
    ## UNIQUE FEATURE ##
    ####################

    def create_unique_list(self,func):
        """ This function is going to ensure that the attribute list returned has no duplicates
        :param func: function that is going to generate the list
        :return: list of elements without duplicates
        """
        # Vars
        ret_unique_list = []
        num_required = self.att_num
        # We start from the premise that we can find duplicates
        has_duplicates = True
        while has_duplicates:
            # we use the past function as argument to generate the list
            this_list = func(num_required)
            # join the returned list with the final list
            ret_unique_list = ret_unique_list + this_list
            # eliminate duplicates
            set_no_dup = set(ret_unique_list)
            ret_unique_list = list(set_no_dup)
            # validate the length after removing duplicates
            list_len = len(ret_unique_list)
            if list_len == self.att_num:
                has_duplicates = False
            else:
                # If we have eliminated duplicates we need to ask for more elements to add to the list
                num_required = self.att_num - list_len
        # return the list with unique elements
        return ret_unique_list

    ####################
    ##  ENTRY  POINT  ##
    ####################

    def create_attribute(self, att_dic, att_num):
        """ This is the single entry point to create a list of attributes
        :param att_dic: Dictionary with the recipe to create the attribute
        :param att_num: Number of attributes to create (inside a list)
        """
        self.att_dic = att_dic
        self.att_num = att_num
        # We obtain the type of attribute to decide how to process it
        this_type = att_dic[ConfigVariablesEnv.attribute_type]
        # We obtain the type of constraint (UNIQUE)
        this_const = att_dic[ConfigVariablesEnv.attribute_constr]
        # Now depending on the type we call the specific creation method
        if this_type == ConfigVariablesEnv.att_type_number:
            if this_const == ConfigVariablesEnv.attribute_unique:
                ret_list = self.create_unique_list(self.create_numbers)
            else:
                ret_list = self.create_numbers(self.att_num)
            return ret_list
        elif this_type == ConfigVariablesEnv.att_type_text:
            pass
        elif this_type == ConfigVariablesEnv.att_type_date:
            pass
        elif this_type == ConfigVariablesEnv.att_type_combined:
            pass
        elif this_type == ConfigVariablesEnv.att_type_conditioned:
            pass
        else:
            list_var_message = [ConfigErrorMessages.ErrorCode003, this_type, ConfigVariablesEnv.att_type_number,
                                ConfigVariablesEnv.att_type_text, ConfigVariablesEnv.att_type_date,
                                ConfigVariablesEnv.att_type_combined, ConfigVariablesEnv.att_type_conditioned]
            log_object = 'Attribute.create_attribute()'
            log(ConfigCommonVariables.level_error, list_var_message, log_object)
