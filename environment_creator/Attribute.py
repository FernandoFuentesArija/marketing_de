from environment_creator.config import ConfigVariablesEnv
from common_tools.logger import log
from common_tools.config import ConfigCommonVariables
from common_tools.config import ConfigErrorMessages
import random
import string
from datetime import date

class Attribute:
    """ Base class to manage attributes

    The environment is composed of objects. These objects have characteristics that define them. Those characteristics
    we are going to call them attributes and they are going to be generated by this class.
    We are going to have 5 different types of atributes:
    1-NUMBER: We can generate a list of numbers, randomly or in sequence. We also define the precision and the range.
    2-TEXT: We can generate a list of texts, randomly, using a constant or selecting them from a database.
    3-DATE:
    4-COMBINED: Pending to develope.
    5-CONDITIONED: Pending to develope.
    Note: The list returned, can be of unique elements, or can have duplicates. It will be defined in the
    <attribute_constr> variable.

    ATTRIBUTES
    ---------
    It's composed:
    - self.bbdd: Object that represents the connection to the bbdd
    - self.att_dic: Dictionary with the recipe to create the attribute
    - self.att_num: Number of attributes to create (inside a list)

    PUBLIC METHODS
    ---------------
    - create_attribute: This is the single entry point to create a list of attributes.

    PRIVATE METHODS
    ---------------
    - create_numbers
    - create_random_numbers
    - create_seq_numbers

    PERSISTENCE
    ------------
    - The initialization of this class accepts an object that represents the connection to a database.

    RELATIONS WITH OTHER ELEMENTS
    ------------------------------
    -[element name]: La
    """

    # Le pasamos una conexion a cada instancia (puede ser la misma)
    def __init__(self, ddbb_conn):
        """ For every instance we need 3 parameters
        :param ddbb_conn: Object that represents the connection to the bbdd
        """
        self.bbdd = ddbb_conn

    ####################
    ## NUMBER METHODS ##
    ####################

    def create_numbers(self,list_length):
        """ This function creates a list of numbers
        The dictionary that will describe how to generate the list of numbers will have the following keys
        - 'PRECISION': Will describe the length of the decimal part.
           Ej: if we want describe 9999.99  Ej_dic: 'PRECISION':'2'
        - 'RANGE': Establish the integer range (min-max) where the number are going to be created.
           Ej: if we want numbers between 10 and 100  Ej_dic: 'RANGE':'10-100'
        - 'GENERATION': It describes how the numbers are going to be created. The can be create randomly or as a
           secuence with certain hop.
           Ej_dic: 'GENERATION':'RANDOM' or 'GENERATION':'SEQUENTIAL'
        - 'HOP': In a sequential number generation is the separation between generated numbers.
           Ej: if we want 2,4,6,...  Ej_dic: 'HOP':'2'
        :param list_length: number of numbers to generate and return in a list
        :return: list of numbers generated
        """
        # First we obtain all the relevant information that we need
        this_precision = self.att_dic[ConfigVariablesEnv.num_precision]
        this_range = self.att_dic[ConfigVariablesEnv.num_range]
        this_generation = self.att_dic[ConfigVariablesEnv.num_generation]
        # From the precision we obtain de decimal and integer accuracy
        dec_pre = int(this_precision)
        # From the range we obtain de max and min numbers
        min_rang, max_rang = this_range.split('-')
        min_rang = int(min_rang)
        max_rang = int(max_rang)
        # Depending on the type of generation
        if this_generation == ConfigVariablesEnv.num_gen_seq:
            # If the generation is sequential we need to recover the hop.
            this_hop_str = self.att_dic[ConfigVariablesEnv.num_hop]
            this_hop_int = int(this_hop_str)
            ret_list = self.create_seq_numbers(min_rang, max_rang, list_length, this_hop_int)
            return ret_list
        elif this_generation == ConfigVariablesEnv.num_gen_random:
            ret_list = self.create_random_numbers(dec_pre, min_rang, max_rang, list_length)
            return ret_list
        else:
            list_var_message = [ConfigErrorMessages.ErrorCode001, this_generation, ConfigVariablesEnv.num_gen_seq,
                                ConfigVariablesEnv.num_gen_random]
            log_object = 'Attribute.create_numbers()'
            log(ConfigCommonVariables.level_error, list_var_message, log_object)


    def create_random_numbers(self,decimal_prec,min_num, max_num, list_length):
        """ This function will create and return a list of random numbers
        :param decimal_prec: Number of digits for the decimal part
        :param min_num: Minimun number allowed
        :param max_num: Maximun number allowed
        :param list_length: number of numbers to generate and return in a list
        :return: list of random numbers generated
        """
        # The list to return
        ret_list = []
        # We create the decimal deviation
        ten_mult = 10**decimal_prec
        # We escalate the range if we have decimals
        min_num_scal = min_num * ten_mult
        max_num_scal = max_num * ten_mult
        for i in range(list_length):
            new_num_scal = random.randint(min_num_scal,max_num_scal)
            new_num = new_num_scal / ten_mult
            ret_list.append(new_num)
        return ret_list

    def create_seq_numbers(self,min_num, max_num, list_length,hop):
        """ This function will create and return a list of sequence integer numbers
        :param decimal_prec: Number of digits for the decimal part
        :param min_num: Minimun number allowed
        :param max_num: Maximun number allowed
        :param list_length: number of numbers to generate and return in a list
        :return: list of sequential numbers generated
        """
        # We use range
        new_range = range(min_num,max_num,hop)
        new_range_list = list(new_range)
        # Validation of the size
        new_range_list_len = len(new_range_list)
        if new_range_list_len != list_length:
            list_var_message = [ConfigErrorMessages.ErrorCode002, str(min_num), str(max_num), str(hop),
                                str(new_range_list_len), str (list_length)]
            log_object = 'Attribute.create_seq_numbers()'
            log(ConfigCommonVariables.level_error, list_var_message, log_object)
        # Finish
        return new_range_list

    ####################
    ##  TEXT METHODS  ##
    ####################

    def create_text(self,list_length):
        """ This function creates a list of texts
        The dictionary that will describe how to generate the list of numbers will have the following keys
        - 'LENGTH': Will describe the length of the text (only use for 'GENERATION':'RANDOM').
           Ej: if we want a text of 10 Characters max  Ej_dic: 'LENGTH':'10'
        - 'GENERATION': It describes how the text are going to be created. We have 3 options:
           - BBDD: We take the text from a populated BBDD.
           - RANDOM: We generate a random text.
           - CTE: We use a constant.
           Ej_dic: 'GENERATION':'BBDD' or 'GENERATION':'RANDOM' or 'GENERATION':'CTE'
        - 'BBDD_SOURCE': If 'GENERATION':'BBDD' we need to inform source where we have to search for the field. In a
           relation database will be the table in a document database will be collections.
           Ej: if the BBDD collection is data_person_names  Ej_dic: 'BBDD_SOURCE':'data_person_names'
        - 'BBDD_FIELD': If 'GENERATION':'BBDD' we need to inform which field to pick as the text. In a
           relation database will be the column name in a document database will be key name.
           Ej: if the BBDD key is name  Ej_dic: 'BBDD_FIELD':'name'
        - 'CTE_STR': If 'GENERATION':'CTE' we need to inform which constant we are going to use
           Ej: if we want to put 'Hello world'  Ej_dic: 'CTE_STR':'Hello world'
        :param list_length: number of texts to generate and return in a list
        :return: list of numbers generated
        """
        # First we obtain the generation
        this_generation = self.att_dic[ConfigVariablesEnv.txt_generation]
        # Depending on the type of generation we choose the specific function
        if this_generation == ConfigVariablesEnv.txt_gen_random:
            # We obtain the length desired
            str_txt_length = self.att_dic[ConfigVariablesEnv.txt_length]
            int_txt_length = int(str_txt_length)
            # We call the specific function
            ret_txt_list = self.create_random_txt(list_length, int_txt_length)
            return ret_txt_list
        elif this_generation == ConfigVariablesEnv.txt_gen_cte:
            # We obtain the constant to use
            cte_text = self.att_dic[ConfigVariablesEnv.txt_cte]
            # We call the specific function
            ret_txt_list = self.create_cte_txt(list_length, cte_text)
            return ret_txt_list
        elif this_generation == ConfigVariablesEnv.txt_gen_bbdd:
            # We obtain the source and the field
            bbdd_source = self.att_dic[ConfigVariablesEnv.txt_bbdd_source]
            bbdd_field = self.att_dic[ConfigVariablesEnv.txt_bbdd_field]
            # We call the specific function
            ret_txt_list = self.create_txt_from_bbdd(list_length, bbdd_source, bbdd_field)
            return ret_txt_list
        else:
            list_var_message = [ConfigErrorMessages.ErrorCode004, this_generation, ConfigVariablesEnv.txt_gen_random,
                                ConfigVariablesEnv.txt_gen_cte, ConfigVariablesEnv.txt_gen_bbdd]
            log_object = 'Attribute.create_text()'
            log(ConfigCommonVariables.level_error, list_var_message, log_object)


    def create_random_txt(self, list_length, txt_length):
        """ This function will create and return a list of random texts made of only letters
        :param list_length: Length of the list to return
        :param txt_length: Number of characters that has to contain the texts
        :return: list of sequential texts generated
        """
        ret_rand_txt_list = []
        for i in range(list_length):
            ran_str = ''.join(random.choice(string.ascii_letters) for m in range(txt_length))
            ret_rand_txt_list.append(ran_str)
        return ret_rand_txt_list


    def create_cte_txt(self, list_length, cte_text):
        """ This function will create and return constant text list
        :param list_length: Length of the list to return
        :return: list of sequential texts generated
        """
        ret_rand_txt_list = []
        for i in range(list_length):
            ret_rand_txt_list.append(cte_text)
        return ret_rand_txt_list

    def create_txt_from_bbdd(self, list_length, source, field):
        """ This function will create and return list of texts extracted from a BBDD.
        :param list_length: Length of the list to return
        :param source: Source(table, collection,...) of the BBDD we have to access
        :param field: Field (column, key,...) of the source that we have to take as an element of the list
        :return: list of sequential texts generated
        """
        # set the variables
        ret_rand_txt_list = []
        good_length = list_length
        ask_for_length = list_length
        # We start from the premise that the length is not good
        bad_length = True
        while bad_length:
            ret_cur = self.bbdd.pick_random_docs(source,ask_for_length)
            for doc in ret_cur:
                value = doc[field]
                ret_rand_txt_list.append(value)
            # validate the length after reading all the cursor
            list_len = len(ret_rand_txt_list)
            if list_len == good_length:
                bad_length = False
            else:
                # If we haven't reach the desired length we need to ask for more elements to add to the list
                ask_for_length = good_length - list_len
        return ret_rand_txt_list

    ####################
    ##  DATE METHODS  ##
    ####################

    def create_date(self,list_length):
        """ This function creates a list of dates
        The dictionary that will describe how to generate the list of numbers will have the following keys
        - 'GENERATION': It describes how the dates are going to be created. We have 2 options:
           - RANDOM: We generate a random date between two established values.
           - CTE: We use a constant date.
           Ej_dic: 'GENERATION':'RANDOM' or 'GENERATION':'CTE'
        - 'MIN_DATE': If 'GENERATION':'RANDOM' we need to inform the minimal date we can choose.
           Ej: if the lower limit is 1984-10-20  Ej_dic: 'MIN_DATE':'1984-10-20'
        - 'MAX_DATE': If 'GENERATION':'RANDOM' we need to inform the maximal date we can choose.
           Ej: if the upper limit is 2015-09-15  Ej_dic: 'MAX_DATE':'2015-09-15'
        - 'CTE_DATE': If 'GENERATION':'CTE' we need to inform which constant date are we going to use
           Ej: if we want to put '1956-03-25'  Ej_dic: 'CTE_DATE':'1956-03-25'
        :param list_length: number of dates to generate and return in a list
        :return: list of dates generated
        """
        # First we obtain the generation
        this_generation = self.att_dic[ConfigVariablesEnv.date_generation]
        # Depending on the type of generation we choose the specific function
        if this_generation == ConfigVariablesEnv.date_gen_random:
            # We obtain the length desired
            str_date_min = self.att_dic[ConfigVariablesEnv.date_min]
            str_date_max = self.att_dic[ConfigVariablesEnv.date_max]
            # We call the specific function
            ret_txt_list = self.create_random_date(list_length, str_date_min, str_date_max)
            return ret_txt_list
        elif this_generation == ConfigVariablesEnv.date_gen_cte:
            # We obtain the constant to use
            cte_date = self.att_dic[ConfigVariablesEnv.date_cte]
            # We call the specific function
            ret_txt_list = self.create_cte_date(list_length, cte_date)
            return ret_txt_list
        else:
            list_var_message = [ConfigErrorMessages.ErrorCode004, this_generation, ConfigVariablesEnv.date_gen_random,
                                ConfigVariablesEnv.date_gen_cte]
            log_object = 'Attribute.create_date()'
            log(ConfigCommonVariables.level_error, list_var_message, log_object)

    def create_cte_date(self, list_length, cte_date):
        """ This function will create and return constant date list
        :param list_length: Length of the list to return
        :return: list of sequential texts generated
        """
        ret_rand_date_list = []
        cte_year, cte_month, cte_day = cte_date.split('-')
        for i in range(list_length):
            ret_rand_date_list.append(date(int(cte_year), int(cte_month), int(cte_day)))
        return ret_rand_date_list

    def create_random_date(self, list_length, min_date, max_date):
        """ This function will create and return random date list
        :param list_length: Length of the list to return
        :return: list of random dates generated
        """
        ret_rand_date_list = []
        format = '%Y-%m-%d'
        min_year, min_month, min_day = min_date.split('-')
        max_year, max_month, max_day = max_date.split('-')
        sdate = date(int(min_year), int(min_month), int(min_day))
        edate = date(int(max_year), int(max_month), int(max_day))
        for i in range(list_length):
            seed = random.random()
            ptime = sdate + seed * (edate - sdate)
            ret_rand_date_list.append(ptime)
        return ret_rand_date_list

    ####################
    ## UNIQUE FEATURE ##
    ####################

    def create_unique_list(self,func):
        """ This function is going to ensure that the attribute list returned has no duplicates
        :param func: function that is going to generate the list
        :return: list of elements without duplicates
        """
        # Vars
        ret_unique_list = []
        num_required = self.att_num
        # We start from the premise that we can find duplicates
        has_duplicates = True
        while has_duplicates:
            # we use the past function as argument to generate the list
            this_list = func(num_required)
            # join the returned list with the final list
            ret_unique_list = ret_unique_list + this_list
            # eliminate duplicates
            set_no_dup = set(ret_unique_list)
            ret_unique_list = list(set_no_dup)
            # validate the length after removing duplicates
            list_len = len(ret_unique_list)
            if list_len == self.att_num:
                has_duplicates = False
            else:
                # If we have eliminated duplicates we need to ask for more elements to add to the list
                num_required = self.att_num - list_len
        # return the list with unique elements
        return ret_unique_list

    ####################
    ##  ENTRY  POINT  ##
    ####################

    def create_attribute(self, att_dic, att_num):
        """ This is the single entry point to create a list of attributes
        :param att_dic: Dictionary with the recipe to create the attribute
        :param att_num: Number of attributes to create (inside a list)
        """
        self.att_dic = att_dic
        self.att_num = att_num
        # We obtain the type of attribute to decide how to process it
        this_type = att_dic[ConfigVariablesEnv.attribute_type]
        # We obtain the type of constraint (UNIQUE)
        this_const = att_dic[ConfigVariablesEnv.attribute_constr]
        # Now depending on the type we call the specific creation method
        if this_type == ConfigVariablesEnv.att_type_number:
            if this_const == ConfigVariablesEnv.attribute_unique:
                ret_list = self.create_unique_list(self.create_numbers)
            else:
                ret_list = self.create_numbers(self.att_num)
            return ret_list
        elif this_type == ConfigVariablesEnv.att_type_text:
            if this_const == ConfigVariablesEnv.attribute_unique:
                ret_list = self.create_unique_list(self.create_text)
            else:
                ret_list = self.create_text(self.att_num)
            return ret_list
        elif this_type == ConfigVariablesEnv.att_type_date:
            if this_const == ConfigVariablesEnv.attribute_unique:
                ret_list = self.create_unique_list(self.create_date)
            else:
                ret_list = self.create_date(self.att_num)
            return ret_list
        elif this_type == ConfigVariablesEnv.att_type_combined:
            pass # Not done yet
        elif this_type == ConfigVariablesEnv.att_type_conditioned:
            pass # Not done yet
        else:
            list_var_message = [ConfigErrorMessages.ErrorCode003, this_type, ConfigVariablesEnv.att_type_number,
                                ConfigVariablesEnv.att_type_text, ConfigVariablesEnv.att_type_date,
                                ConfigVariablesEnv.att_type_combined, ConfigVariablesEnv.att_type_conditioned]
            log_object = 'Attribute.create_attribute()'
            log(ConfigCommonVariables.level_error, list_var_message, log_object)
